# SQLite 数据库读写问题分析

## 发现的主要问题

### 1. **多个 DbContext 实例同时访问同一个数据库文件**
   - **问题**：MainForm 创建了一个 ApplicationDbContext 实例，ApiServer 通过依赖注入创建了另一个实例
   - **影响**：两个不同的 DbContext 实例同时访问同一个 SQLite 文件，可能导致锁定和权限冲突
   - **解决方案**：使用 `Cache=Shared` 启用共享缓存，允许多个连接共享同一个缓存

### 2. **不必要的连接状态检查**
   - **问题**：在 WebViewBridge 中多次检查连接状态，EF Core 会自动管理连接
   - **影响**：可能导致连接状态混乱，影响性能
   - **解决方案**：移除所有手动连接状态检查，让 EF Core 自动管理

### 3. **权限检查过于频繁**
   - **问题**：在每次 SaveChanges 时都调用 EnsureDatabaseWritable，打开文件测试权限
   - **影响**：可能导致文件锁定，与其他连接冲突
   - **解决方案**：移除 SaveChanges 中的权限检查，只在 OnConfiguring 时检查一次

### 4. **连接字符串配置不完整**
   - **问题**：缺少 `Foreign Keys=True` 等关键配置
   - **影响**：可能影响数据完整性
   - **解决方案**：添加完整的连接字符串配置

## 已实施的改进

### 1. **简化 SaveChanges 方法**
   - 移除了每次保存时的权限检查
   - 保留异常处理，提供详细的错误信息

### 2. **简化 OnConfiguring 方法**
   - 只在配置时检查文件是否只读
   - 不阻塞连接创建，让 SQLite 处理权限问题

### 3. **改进连接字符串**
   - 添加 `Cache=Shared` 支持并发访问
   - 添加 `Foreign Keys=True` 启用外键约束
   - 配置命令超时

### 4. **移除不必要的连接状态检查**
   - 移除 WebViewBridge 中的连接状态检查
   - 让 EF Core 自动管理连接生命周期

## 建议的进一步优化

1. **统一 DbContext 管理**：考虑使用单例模式或依赖注入统一管理 DbContext
2. **连接池配置**：确保连接池大小合适
3. **错误重试机制**：在应用层添加重试逻辑
